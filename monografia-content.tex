\chapter{Introdução}

Arquitetura de software de um programa é a estrutura que define as propriedades
externamente visíveis e o relacionamento entre os grandes componentes
estruturais de um sistema \cite{engenhariaDeSoftwarePressman}, esta arquitetura
pode estar ou não documentada em forma de diagramas, grafos, tabelas ou documentos.
Todo projeto de software possui uma arquitetura implícita, ter esta arquitetura
documentada pode ser útil para possibilitar, por exemplo, a extração de
métricas de modularidade ou para estudar o impacto de possíveis alterações de
um projeto \cite{mata26-terceiro-projeto-piloto}.

A arquitetura de grandes projetos de software raramente são documentados e
quando são usualmente estão desatualizados
\cite{sourceVersusObjectCodeExtraction}, ter a arquitetura documentada e
atualizada é importante, por exemplo, como forma apoio para os desenvolvedores
e novos colaboradores.

Existem, hoje, diversas ferramentas capazes de extrair do código fonte ou do
código objeto a arquitetura de software de um sistema, entre as opções
pesquisadas \cite{sourceVersusObjectCodeExtraction} a maioria delas faz uso do
código objeto, ou seja, faz uso de dados resultantes da compilação do código
fonte.

Uma desvantagem em se utilizar código objeto é que fica impossível
analisar projetos que não compilem mais, seja por falhas no código ou por
possuir dependencias não satisfeitas. Além disso algumas informações como por
exemplo macros em projetos C/C++ são perdidas durante a
compilação \cite{sourceVersusObjectCodeExtraction}.

Este trabalho baseia-se na implementação de uma extensão para o egypt que
possibilite a extração de informação de dependências entre módulos de programas
C/C++ baseada em código fonte. O egypt é uma ferramenta originalmente escrita
com o objetivo de gerar gráficos de chamada entre funções de programas escritos
em C e que usa como base código objeto, ele será visto com mais detalhes na
seção~\ref{sec:egypt} do capítulo~\ref{ch:implementacao}.

Essa extensão para o egypt além de possibilitar analisar projetos que não
compilem mais trará informações mais precisas já que alguns dados importantes
não se perderão como acontece por exemplo com macros em projetos C/C++
\cite{sourceVersusObjectCodeExtraction} que se perdem durante a compilação.

Este trabalho está organizado da seguinte forma. No capítulo~\ref{ch:conceitos}
são abordados conceitos básicos de arquitetura de software e atributos de
modularidade como acoplamento e coesão. No capítulo~\ref{ch:implementacao} será
demonstrado como a ferramenta foi implementada. No capítulo~\ref{ch:avaliacao}
os resultados obtidos pela ferramenta são avaliados com um estudo de caso. O
capítulo~\ref{ch:conclusao} apresenta as conclusões e trabalhos futuros.

% ----------- CONCEITOS -------------

\chapter{Conceitos} \label{ch:conceitos}

Neste capítulo serão apresentados os conceitos fundamentais utilizados neste
trabalho para a avaliação dos resultados gerados pela ferramenta desenvolvida.

\section{Arquitetura de Software}

Arquitetura de software de um programa é a estrutura que define as propriedades
externamente visíveis e o relacionamento entre os grandes componentes
estruturais do sistema \cite{engenhariaDeSoftwarePressman}.

\citeonline{engenhariaDeSoftwarePressman} destaca 3 razões principais sobre a
importância da arquitetura de software:

\begin{itemize}

\item Representações da arquitetura de software constituem um facilitador da
comunicação entre todas as partes interessadas no desenvolvimento de um
sistema.

\item A arquitetura destaca decisões iniciais de projeto que terão um impacto
profundo em todo o trabalho de engenharia de software que se segue.

\item A arquitetura compõe uma representação de simples entendimento de como o
sistema é estruturado e como se interrelacionam os seus componentes.

\end{itemize}

Apesar de Pressman, aqui, destacar apenas a importancia da arquitetura de
software nas decisões iniciais do projeto, ela é de suma importancia durante
todo o processo de desenvolvimento de um projeto.

Neste trabalho a documentação da arquitetura de software de um programa será
utilizada com o objetivo de calcular métricas que possibilitem avaliar a
qualidade do sistema em relação aos seus atributos de modularidade.

\section{Atributos de Modularidade}

A medição é um elemento fundamental para qualquer processo de engenharia
\cite{engenhariaDeSoftwarePressman}. As métricas de software são um modo
poderoso de prover indicadores de modularidade da arquitetura de um sistema
\cite{OntheModular}.

Um dos conjuntos de métricas de software OO\sigla{OO}{Orientação a Objetos}
mais amplamente referenciado foi proposto por Chidamber e Kemerer
\cite{engenhariaDeSoftwarePressman}, eles propuseram seis métricas:

\begin{description}

\item[WMC\sigla{WMC}{Weighted Methods per Class}]
Métodos ponderados por classe (weighted methods per class).

\item[DIT\sigla{DIT}{Depth of the Inheritance Tree}]
Profundidade de árvore de herança (depth of the inheritance tree).

\item[NOC\sigla{NOC}{Number of Children}]
Número de filhos (number of children).

\item[CBO\sigla{CBO}{Coupling Between Objects classes}]
Acoplamento entre as classes de objetos (coupling between objects classes).

\item[RFC\sigla{RFC}{Response For a Class}]
Resposta de uma classe (response for a class).

\item[LCOM\sigla{LCOM}{Lack of Cohesion in Methods}]
Falta de coesão em métodos (lack of cohesion in methods).

\end{description}

Este trabalho fundamenta-se em 2 das métricas acima, CBO e LCOM, que são
métricas que levam em consideração atributos de acoplamento e coesão.

\subsection{Acoplamento}

Acoplamento é a medida qualitativa de conexões entre os componentes de um
sistema, ele representa o nível de interdependências entre os módulos de um
sistema, quando maior o acoplamento maior a complexidade. Então o desejável é
ter baixo acoplamento, mas algum acoplamento é inevitável e em alguns momentos
não será possível diminuí-lo.

A métrica para cálculo de acoplamento utilizada neste trabalho será CBO, esta
métrica é calculada contando-se o número de colaborações de um módulo com as
outras entidades do sistema. Na figura~\ref{fig:exemplo-cbo} tem um grafo
simples para exemplo de cálculo desta métrica, onde {\it module1} colabora com
{\it module2} e {\it module3}, então {\it module1} tem CBO = 2.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/exemplo-cbo}
\caption{Grafo de colaboração exemplo para cálculo de CBO}
\label{fig:exemplo-cbo}
\end{figure}

Valores de CBO altos podem significar que a reusabilidade de um módulo é
pequena \cite{engenhariaDeSoftwarePressman}, além de implicar que a manutenção
e os testes serão mais complexos de ser feitos. Em geral o ideal é que os
valores de CBO sejam baixos.

\subsection{Coesão}

Coesão é a medida que define o quanto um módulo de um programa está focado em
solucionar um único problema. \citeonline{engenhariaDeSoftwarePressman} define
coesão da seguinte forma: ''{\it coesão} implica que um componente ou classe
encapsule somente os atributos e operações muito relacionados entre si e com a
classe ou componente propriamente dito''.

A métrica utilizada neste trabalho será a falta de coesão em métodos ({\it lack
of cohesion in methods} - LCOM), proposta por \citeonline{aMetricsSuiteForOO}.
LCOM é a diferença entre o número de métodos num mesmo componente que
compartilham atributos e o número de métodos que não compartilham
atributos, se nenhum método compartilha atributos então LCOM é 0. Na
figura~\ref{fig:exemplo-lcom} a classe {\it module1} tem $LCOM = 2 - 1 = 1$, a
variável {\it nome} é compartilhada entre os métodos {\it imprime} e {\it
exporta} e o método {\it aniversario} não compartilha nenhuma variável com
nenhum outro método.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/exemplo-lcom}
\caption{Exemplo de troca de mensagens internas de module1 para cálculo de LCOM}
\label{fig:exemplo-lcom}
\end{figure}

É desejável que a coesão dos componentes de um sistema seja alta, isto garante
que o acoplamento do sistema seja baixo e como consequência a complexidade do
sistema cai facilitando a manutenção e o desenvolvimento. LCOM mede a falta de
coesão, então valores baixos significam boa coesão, e valores altos significam
que métodos podem estar acoplados uns aos outros através de atributos, e que é
melhor dividir o módulo em submódulos\cite{observationsOnLCOM}.

Após a publicação de \citeonline{aMetricsSuiteForOO} para o cálculo de LCOM vários
autores propuseram modificações e melhorias deste método, as mais significantes
incluindo a definição original são \cite{principalComponentAnalysisOfLCOM}:

\begin{itemize}
\item A definição original por Chidamber e Kemerer - LCOM1;
\item A definição de Li e Henry - LCOM?;
\item A redefinição do LCOM de Li e Henry por Hitz e Montazeri - LCOM4; e
\item A redefinição da proposta original pelos próprios Chidamber and Kemerer - LCOM?.
\end{itemize}

A definição original por \citeonline{principalComponentAnalysisOfLCOM},
conhecida como LCOM1, após sua publicação recebeu algumas críticas, uma delas
feita por \citeonline{aCritiqueOfCohesion} onde diz: ''LCOM1 não é um caminho
válido para medir coesão de classes, sua definição é baseada em iterações entre
método e dados, o que pode não ser um bom caminho para definir coesão no mundo
da orientação a objetos. Além disso, para classes muito diferentes ela dar
valores de LCOM1 iguais''.

LCOM1 é calculado da seguinte forma, considere C1 uma classe com M1, M2,
\ldots, Mn métodos e Ii o conjunto de atributos (variábeis de instancia) de C1
sendo usado pelo método Mi. Para cada método Mi de C1 deve existir um grupo de
atributos Ii correspondente. LCOM é Número distinto de grupos formados pela
intersecção dos 'n' conjuntos.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/exemplo-lcom1-hitz-e-montazeri}
\caption{Exemplo LCOM1 \cite{measuringCouplingAndCohesion}}
\label{fig:exemplo-lcom1}
\end{figure}

Por exemplo, na classe da figura~\ref{fig:exemplo-lcom1}, existem 2 pares de
métodos que não compartilham nenhuma variável ($<f, g>$ e $<f, h>$) e
exatamente um par que compartilha a variável E ($<g, h>$). Portanto, LCOM1 é $2
- 1 = 1$.

De acordo com os estudos de \citeonline{measuringCouplingAndCohesion} sobre
LCOM1 eles chegam a conclusão que apesar deste cálculo ser baseado numa idéia
muito sensata ele traz algumas anomalias nos resultados, como no exemplo da
figura~\ref{fig:exemplo-anomalia-lcom1}, onde os autores concluem que os 2
casos são igualmente não-coesivos e deveriam ter valores de LCOM iguais, mas
o cálculo de LCOM1 traz resultados diferentes.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/exemplo-anomalia-lcom1-hitz-e-montazeri}
\caption{Exemplo anomalia LCOM1 \cite{measuringCouplingAndCohesion}}
\label{fig:exemplo-anomalia-lcom1}
\end{figure}

Eles então se baseiam numa proposta de
\citeonline{principalComponentAnalysisOfLCOM} para uma nova definição de LCOM
que diz: ''LCOM é o número de grupos de métodos locais distintos, onde cada
grupo tem um ou mais métodos de classe locais, e ao menos 2 desses métodos
acessam pelo menos um atributo de classe em comum; o número de atributos comuns
pode variar de 0 à N (onde N é um inteiro maior que 0)''.

Com esta definição, um valor $K > 1$ para $LCOM(X)$ sinaliza a possibilidade de
dividir X em k módulos menores e mais coesos. Aplicando esta definição aos
casos I e II da figura acima produzem valor 2 em todos os casos, que de acordo
com os autores faz mais sentido\cite{measuringCouplingAndCohesion}.

Com base nesta proposta de cálculo de
\citeonline{principalComponentAnalysisOfLCOM}
\citeonline{measuringCouplingAndCohesion} propõem uma nova definição usando
representação de teoria dos grafos, como se segue:

\begin{quotation}
Seja X uma classe, IX um grupo de variáveis de instancia de X, e MX um grupo
de seus métodos. Considere um simples grafo indireto $GX(V, E)$, onde: $$V =
MX$$ $$E = \{<m, n> \in V \times V \mid \exists i \in IX: (m \; acessos \; a \;
i) (n \; acessos \; a \; i)\}$$ LCOM(X) é então definido como o número de componentes
conectados de GX $(1 \leq LCOM(X) \leq |MX|)$.
\end{quotation}

Esta definição por \citeonline{measuringCouplingAndCohesion} conhecida como
LCOM4 será junto a métrica de acoplamento CBO as métricas abordadas neste
trabalho no capítulo~\ref{ch:avaliacao}.

% ----------- IMPLEMENTACAO -------------

\chapter{Implementação do Extrator} \label{ch:implementacao}

Neste capítulo será apresentado como o extrator foi implementado e as
ferramentas utilizadas como base para a implementação.

\section{egypt} \label{sec:egypt}

O egypt foi originalmente desenvolvido por Andreas
Gustafsson\footnote{http://www.gson.org/egypt} com o objetivo de gerar gráficos
de chamada entre funções de programas escritos em C, ele funciona lendo os

arquivos intermediários gerados pelo GCC\sigla{GCC}{GNU C Compiler} e os converte num gráfico de chamada
no formato usado pelo Graphviz\footnote{http://www.graphviz.org}, um programa
para visualização de gráficos.

O egypt é Software Livre e em Janeiro de 2009 começou a ser restruturado por
Antonio Terceiro o qual o tem mantido
em\footnote{http://github.com/terceiro/egypt}. As principais mudanças sofridas
pelo egypt deste então foram \cite{structuralComplexityEvolution}:

\begin{itemize}
\item Detecção de uso de variáveis, para identificar que função usa qual
variável.
\item Opção para agrupar chamada e uso de variaveis por módulo, com isto é
possível ter uma visão de dependência entre módulos.
\item Refatoração do script egypt em um design orientado a objetos, para
permitir diferentes módulos de extração e relatório.
\item Geração de relatório de métricas, como coesão e acoplamento por exemplo.
\end{itemize}

Segue abaixo como ficou estruturado o egypt após a refatoração:

\begin{description}
\item[egypt] Script principal
\item[Egypt::Extractor] Extrator baseado nos arquivos intermediários do GCC
\item[Egypt::Metrics] Gera relatório de métricas com os dados do Egypt::Model
\item[Egypt::Model] Armazena os dados obtidos pelo extrator
\item[Egypt::Output::DOT] Gera saída no formato do Graphviz com os dados de Egypt::Model
\end{description}

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/egypt-fluxogram}
\caption{Fluxograma de funcionamento do egypt}
\label{egypt-fluxogram}
\end{figure}

No fluxograma da figura~\ref{egypt-fluxogram} temos o seguinte: Egypt::Model é
alimentado com informações sobre declaração e uso de símbolos extraídos pelo
Egypt::Extractor e o Egypt::Output lê as informações contidas nele e gera saída
no formato apropriado.

\section{Doxygen (e a sua API)}

Doxygen\footnote{http://www.doxygen.org} é um sistema de documentação para C++,
C, Java, Objective-C, Python, IDL\sigla{IDL}{Interface Definition Language},
Fortran, VHDL\sigla{VHDL}{VHSIC (Very High Speed Integrated Circuit) Hardware
Description Language}, PHP e C\#. Com ele é possível gerar documentação em
HTML\sigla{HTML}{HyperText Markup Language}, RTF\sigla{RTF}{Rich Text Format},
PostScript, PDF\sigla{PDF}{Portable Document Format}, \LaTeX\ e man pages, ele
extrai a documentação existente no código fonte e também extrai informações de
hierarquia e colaboração entre os módulos do projeto. É baseado nesta
capacidade de extrair informações de hierarquia e colaboração que o Doxygen foi
escolhido como base para implementação deste novo extrator para o egypt.

O Doxygen é Software Livre e está disponível sob a GPL\sigla{GPL}{GNU Public
License}v2 em
\footnote{https://doxygen.svn.sourceforge.net/svnroot/doxygen/trunk}, junto aos
fontes deste programa existe um pequeno exemplo chamado doxyapp, que foi usado
como base para este projeto já que ele implementa uma ferramenta para análise
de código fonte bem próximo as necessidades deste projeto.

Entre as inúmeras classes presentes na API\sigla{API}{Application Programming
Interface}(Interface de Programação de Aplicativos) do Doxygen é importante
destacar as seguintes:

\begin{description}
\item[Doxygen] Provê um namespace para varáveis e funções globais usadas pelo doxygen
\item[CodeOutputInterface] Interface de saída de trecho de código para os parsers
\item[MemberDef] Definição de um membro ou símbolo de classe
\item[FileDef] Definição de um arquivo
\end{description}

\section{Implementação do Extrator usando a API do Doxygen}

O Doxygen apesar de oferecer todos os recursos necessários para
analisar projetos C/C++ e extrair o uso de símbolos, como funções e variáveis,
que é o objetivo deste projeto, não possibilita que a saída gerada seja
customizada, apenas oferece opções específicas como PDF e HTML por exemplo. É
necessário então adaptar o Doxygen para gerar uma saída num formato
específico e apenas com as informações necessárias, para isto foi criado o
doxyparse, um parser capaz de analisar códigos C/C++ extraindo símbolos
com a identificação de onde são declarados e onde são utilizados.

Seguindo a interface CodeOutputInterface foi possível reaproveitar no doxyparse
todo o poder que o Doxygen fornece e gerar a saída da forma desejada. Na
figura~\ref{doxyparse-diagram} temos o diagrama desta implementação.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/doxyparse-diagram}
\caption{Diagrama da hierarquia de classes do doxyparse}
\label{doxyparse-diagram}
\end{figure}

O doxyparse então reaproveita os recursos existentes no Doxygen para fazer a
análise de código e gerar uma saída que será lida pelo extrator a ser
implementado no egypt, ele redefine algums parâmetros de configuração
do Doxygen para obter o comportamento desejado, como: analisar diretórios
recursivamente, não gerar saida em Latex ou HTML, extrair tanta informação
quanto possível do código fonte, extrair informação de chamada e não gerar
mensagens de aviso.

O doxyparse faz então a análise dos fontes de um diretorio ou arquivo(s)
passados como parâmetro via linha de comando e extrai destes fontes os símbolos
encontrados. Após isto é gerada uma saída num formato específico que será lida
pelo extrator no egypt. Na figura~\ref{exemplo-saida-doxyparse} tem um exemplo
desta saída.

\begin{figure}[h]
\begin{Verbatim}[frame=single,fontsize=\relsize{-2},fontfamily=courier]
module module1.c
   function main in line 5
      uses function callback defined in module3.c
      uses function say_bye defined in module2.c
      uses function say_hello defined in module2.c
      uses variable variable defined in module3.c
\end{Verbatim}
\caption{Exemplo de saída do doxyparse}
\label{exemplo-saida-doxyparse}
\end{figure}

Com a saída gerada pelo doxyparse o egypt precisa agora de um extrator que
entenda estes dados, extraia as informações sobre os símbolos e gere a saída no
formato do Graphviz que irá então gerar o gráfico de chamada entre os módulos.

O extrator atual do egypt, Egypt::Extractor, entende apenas arquivos
intermediários gerados pelo GCC e não é capaz de entender a saída da
figura~\ref{exemplo-saida-doxyparse}. Para isto foi necessário refatorar a
atual implementação do egypt e implementar um novo extrator. Na
figura~\ref{egypt-diagram-extractor} está o desenho desta nova estrutura.

\begin{figure}[h]
\center
\includegraphics[scale=0.4]{imagens/egypt-diagram-extractor}
\caption{Diagrama da hierarquia de classes do extrator do egypt}
\label{egypt-diagram-extractor}
\end{figure}

Abaixo uma breve descrição de cada classe presente na
figura~\ref{egypt-diagram-extractor}:

\begin{description}
\item[Egypt::Extractor] Interface padrão para os extratores.
\item[Egypt::Extractor::GCC] Extrator baseado nos arquivos intermediários do GCC.
\item[Egypt::Extractor::Doxyparse] Novo extrator baseado na saída do doxyparse
\end{description}

Após a refatoração demonstrada na figura~\ref{egypt-diagram-extractor} o egypt
pode extrair informações usando 2 métodos diferentes, usando o
Egypt::Extractor::GCC que faz a extração baseada nos arquivos intermediários do
GCC ou usando o Egypt::Extractor::Doxyparse que faz a análise utilizando o
doxyparse. Segue abaixo um exemplo de execução do egypt usando cada um dos
extratores:

\begin{Verbatim}[frame=single,fontsize=\relsize{-2},fontfamily=courier]
 $ egypt --extractor Doxyparse <arquivos>
 $ egypt --extractor GCC <arquivos>
\end{Verbatim}

% ----------- AVALIACAO -------------

\chapter{Avaliação} \label{ch:avaliacao}

Com o extrator pronto é necessário avaliar se as informações extraídas estão
corretas e se há diferenças em relação as informações extraídas pelo extrator
original do egypt baseado em GCC.

\section{Procedimento}

Em \cite{structuralComplexityEvolution} foi feita uma análise do {\it
ristretto}\footnote{http://goodies.xfce.org/projects/applications/ristretto},
um Software Livre escrito em C para visualização de imagens no ambiente Desktop
Xfce\footnote{http://www.xfce.org}, utilizando o extrator original do egypt, as
informações geradas por esta análise serão utilizadas aqui para comparação com
as informações extraídas pelo novo extrator baseado no doxyparse.

Além da comparação entre o extrator original e o novo extrator a saída
gerada pelo doxyparse, o parser baseado no Doxygen, será analisada em
comparação com o código fonte em busca de inconsistências em relação a
declaração e uso de símbolos encontrados.

Por fim veremos um resumo comparativo onde iremos analisar e interpretar as
diferenças encontradas entre as métricas de coesão e acomplamento calculadas
pelo egypt usando cada um dos extratores.

\section{Resultados}

Vamos avaliar os resultados dos grafos de colaboração e de métricas nas seções
que se seguem.

\subsection{Grafos de colaboração}

Os grafos gerados pelo egypt usando o extrator Doxyparse apresentaram
diferenças em relação ao extrator GCC como demonstram as figuras
\ref{fig:ristretto-0.0.1}, \ref{fig:ristretto-0.0.11} e
\ref{fig:ristretto-0.0.21} referentes as versões 0.0.1, 0.0.11 e 0.0.21 do {\it
ristretto}, respectivamente.

\begin{figure}
\center
\subfigure[Doxyparse]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_1-doxyparse}
   \label{fig:ristretto-0.0.1-doxyparse}
}
\qquad
\subfigure[GCC]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_1-gcc}
   \label{fig:ristretto-0.0.1-gcc}
}
\caption{Grafo de colaboração do ristretto 0.0.1}
\label{fig:ristretto-0.0.1}
\end{figure}

\begin{figure}
\center
\subfigure[Doxyparse]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_11-doxyparse}
   \label{fig:ristretto-0.0.11-doxyparse}
}
\qquad
\subfigure[GCC]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_11-gcc}
   \label{fig:ristretto-0.0.11-gcc}
}
\caption{Grafo de colaboração do ristretto 0.0.11}
\label{fig:ristretto-0.0.11}
\end{figure}

\begin{figure}
\center
\subfigure[Doxyparse]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_21-doxyparse}
   \label{fig:ristretto-0.0.21-doxyparse}
}
\qquad
\subfigure[GCC]{
   \includegraphics[scale=0.3]{imagens/ristretto-0_0_21-gcc}
   \label{fig:ristretto-0.0.21-gcc}
}
\caption{Grafo de colaboração do ristretto 0.0.21}
\label{fig:ristretto-0.0.21}
\end{figure}

Vamos avaliar as diferenças encontradas em cada uma dessas versões:

\begin{itemize}

\item {\it ristretto 0.0.1} - Na figura~\ref{fig:ristretto-0.0.1-gcc} o
extrator GCC encontra uma chamada do módulo {\it navigator} para o módulo {\it
picture\_viewer}, já na figura~\ref{fig:ristretto-0.0.1-doxyparse} o Doxyparse
encontra apenas uma chamada de {\it navigator} para {\it thumbnail\_viewer}.

\item {\it ristretto 0.0.11} - Na figura~\ref{fig:ristretto-0.0.11-gcc} o GCC
encontra uma chamada do módulo {\it main\_window} para o módulo {\it main}, já
no Doxyparse não há nenhuma chamada para o módulo {\it main} como visto na
figura~\ref{fig:ristretto-0.0.11-doxyparse}. 

\item {\it ristretto 0.0.21} - Na figura~\ref{fig:ristretto-0.0.21} temos outra
diferença interessante, o GCC informa que o módulo {\it save\_dialog} é chamado
pelos módulos {\it main\_window}, {\it thumbnail}, {\it navigator}, {\it
picture\_viewer} e {\it thumbnail\_bar}, já o Doxyparse na
figura\ref{fig:ristretto-0.0.21-doxyparse} temos apenas o módulo {\it
main\_window} chamando {\it save\_dialog}.

\end{itemize}

\subsection{Métricas}

O Doxyparse também gerou diferenças no cálculo de métricas pelo egypt, na
tabela~\ref{tab:comparacao-metricas} temos resumo comparativo entre as métricas
geradas pelos extratores GCC e Doxyparse em cada versão do {\it ristretto}.
Nesta tabela são apresentadas a média de acoplamento (CBO) e falta de coesão
entre métodos (LCOM4) para cada versão do ristretto.

\begin{table}
\caption{Resumo comparativo das métricas do ristretto}
\centering
\begin{tabular}{| l | c c | c c |}
\hline
Extrator  & \multicolumn{2}{|c|}{GCC}        & \multicolumn{2}{|c|}{Doxyparse} \\
\hline
Versão    & Falta de Coesão & Acoplamento    & Falta de Coesão & Acoplamento   \\
\hline
0.0.1     & 4.75            & 2.75           & 5.00            & 1.25          \\
0.0.2     & 5.75            & 2.75           & 6.00            & 1.25          \\
0.0.3     & 6.00            & 2.75           & 6.00            & 1.25          \\
0.0.4     & 6.25            & 2.75           & 6.25            & 1.25          \\
0.0.5     & 6.25            & 2.75           & 6.25            & 1.25          \\
0.0.6     & 7.60            & 3.00           & 7.60            & 1.40          \\
0.0.7     & 7.60            & 3.00           & 7.60            & 1.40          \\
0.0.8     & 7.00            & 3.00           & 7.20            & 1.40          \\
0.0.9     & 7.20            & 3.00           & 7.40            & 1.40          \\
0.0.10    & 7.60            & 3.00           & 8.00            & 1.40          \\
0.0.11    & 7.60            & 3.00           & 8.00            & 1.40          \\
0.0.12    & 7.60            & 3.00           & 8.00            & 1.40          \\
0.0.13    & 7.80            & 3.00           & 8.20            & 1.40          \\
0.0.14    & 8.00            & 3.00           & 8.40            & 1.40          \\
0.0.15    & 8.00            & 3.00           & 8.80            & 1.40          \\
0.0.16    & 7.16            & 3.16           & 7.83            & 1.50          \\
0.0.17    & 7.00            & 3.16           & 7.83            & 1.50          \\
0.0.18    & 7.50            & 3.00           & 8.33            & 1.50          \\
0.0.19    & 7.83            & 3.00           & 8.66            & 1.50          \\
0.0.20    & 8.83            & 3.00           & 10.00           & 1.50          \\
0.0.21    & 8.28            & 3.00           & 9.14            & 1.42          \\
\hline
\end{tabular}
\label{tab:comparacao-metricas}
\end{table}

Analisando a tabela é possível notar que a média do acoplamento e da falta de
coesão gerados pelo Doxyparse são menores que os valores gerados pelo GCC em
todas as versões do {\it ristretto}.

Na seção~\ref{sec:discussao} essas diferenças entre cada extrator serão
analisadas e interpretadas.

\section{Discussão} \label{sec:discussao}

A análise dos dados gerados pelo egypt para cada versão do ristretto com o foco
nas diferenças entre os extratores foi importante pois revelou que o egypt e o
doxyparse apresentavam alguns bugs e através desta análise foi possível
identificar e corrigir. Nesta seção veremos cada uma dessas diferenças e
esclarecer como foi corrigidas.

\subsection{Grafos de colaboração}

Ao verificar o código fonte do {\it ristretto} 0.0.1 na busca tentativa de
descobrir a diferença demonstrada na figura~\ref{fig:ristretto-0.0.1} nota-se
que nenhum dos 2 módulos se referenciam, então os dois extratores estão dando
informações incorretas.

O problema pode estar na interpretação dos dados pelo egypt ou nos dados
gerados pelo doxyparse. Após uma verificação na saída do doxyparse, exemplo
abaixo na figura~\ref{fig:trecho-saida-doxyparse-ristretto}, foi possível notar
que os dados estão corretos.

\begin{figure}[h]
\begin{Verbatim}[frame=single,fontsize=\relsize{-3},fontfamily=courier]
module main.c
   variable mime_dbase in line 28
   variable window_fullscreen in line 86
   variable viewer_scale in line 87
   variable menu_bar in line 88
   variable image_tool_bar in line 89
   variable app_tool_bar in line 90
   variable status_bar in line 91
   variable playing in line 92
   variable menu_item_play in line 93
   variable menu_item_pause in line 94
   variable main_hbox in line 96
   variable main_vbox1 in line 97
   variable thumbnail_viewer in line 98
   variable recent_manager in line 99
   variable xfce_rc in line 100
   variable thumbnail_viewer_orientation in line 101
   function cb_rstto_zoom_fit in line 31
      uses function rstto_picture_viewer_fit_scale defined in picture_viewer.c
   function cb_rstto_zoom_100 in line 33
      uses function rstto_picture_viewer_set_scale defined in picture_viewer.c
   function cb_rstto_zoom_in in line 35
      uses function rstto_picture_viewer_get_scale defined in picture_viewer.c
      uses function rstto_picture_viewer_set_scale defined in picture_viewer.c
   function cb_rstto_zoom_out in line 37
      uses function rstto_picture_viewer_get_scale defined in picture_viewer.c
      uses function rstto_picture_viewer_set_scale defined in picture_viewer.c
\end{Verbatim}
\caption{Trecho de saída do doxyparse para o ristretto 0.0.1}
\label{fig:trecho-saida-doxyparse-ristretto}
\end{figure}

Então o problema está na interpretação do egypt aos dados gerados pelo doxyparse.

O egypt armazena as informações usando como chave, ou seja, como identificador
único, o nome do símbolo em questão mas alguns módulos possuem símbolos com o
mesmo nome, isto faz com que o egypt confunda o uso e chamada destes símbolos.

A solução adotada para este problema foi armazenar o nome do módulo junto ao
nome do símbolo, por exemplo ao invés de guardar apenas {\it parent\_class} guarda-se
{\it main::parent\_class}. Na figura \ref{fig:ristretto-0.0.1-doxyparse-2} temos o
grafo atualizado após esta correção.

\begin{figure}[h]
\center
\includegraphics[scale=0.3]{imagens/ristretto-0_0_1-doxyparse-2}
\caption{Grafo de colaboração do ristretto 0.0.1 atualizado}
\label{fig:ristretto-0.0.1-doxyparse-2}
\end{figure}

Na figura~\ref{fig:ristretto-0.0.11} referente ao {\it ristretto 0.0.11} o GCC
diz que o módulo main\_window chama main, já no Doxyparse não há esta chamada.
E de fato, analisando o código fonte do {\it ristretto} 0.0.11 não foi
encontrada nenhuma chamada de main\_window para main, então o Doxyparse está
correto neste caso. Mas ele confunde alguns símbolos como na
figura~\ref{fig:ristretto-0.0.1}, veja na
figura~\ref{fig:ristretto-0.0.11-doxyparse-2} o grafo atualizado após a
correção.

\begin{figure}
\center
\includegraphics[scale=0.3]{imagens/ristretto-0_0_11-doxyparse-2}
\caption{Grafo de colaboração do ristretto 0.0.11 atualizado}
\label{fig:ristretto-0.0.11-doxyparse-2}
\end{figure}

Na figura~\ref{fig:ristretto-0.0.21} onde o GCC diz que o módulo {\it
save\_dialog} é referenciado por vários outros analisando o código fonte do
ristretto 0.0.21 não foi encontrada essas chamadas, então o Doxyparse está
correto ao identificar que o {\it save\_dialog} é chamado apenas por {\it
main\_window}. Mas sobre a chamada de {\it save\_dialog} para {\it
thumbnail\_bar} está incorreta, não há esta chamada nos fontes do projeto. Mas
este problema foi causado pelo mesmo problema já corrigido nos exemplos citados
acima para as versões 0.0.1 e 0.0.11, veja na
figura~\ref{fig:ristretto-0.0.21-doxyparse-2} o grafo atualizado.

\begin{figure}
\center
\includegraphics[scale=0.3]{imagens/ristretto-0_0_21-doxyparse-2}
\caption{Grafo de colaboração do ristretto 0.0.21 atualizado}
\label{fig:ristretto-0.0.21-doxyparse-2}
\end{figure}

Além destas correções no egypt foi necessário corrigir no doxyparse a
identificação de símbolos estáticos, nesta avaliação feita com o {\it
ristretto} o doxyparse apresentou problemas com o uso do simbolo parent\_class,
uma variável estática definida por todos os módulos do projeto. O doxyparse
registra a declaração deste símbolo apenas na primeira vez que é encontrado e
nas ocorrências de uso e chamada nos diversos módulos o doxyparse faz
referência ao primeiro módulo onde o símbolo foi encontrado. Isto foi
solucionado ignorando as chamadas aos símbolos estáticos fora do módulo sendo
analisado, só se considera chamada a símbolos estáticos se eles estiverem no
mesmo módulo que o símbolo.

\subsection{Métricas}

Analisando a tabela~\ref{tab:comparacao-metricas}  é possível notar que o
acoplamento calculado pelo Doxyparse se mantém menor do que o GCC em todas as
versões do {\it ristretto}, já a métrica de Falta de Coesão LCOM4 se mantém
ligeiramente maior também em todas as versões, embora a diferença entre o
Doxyparse e GCC seja pequena neste caso.

Qual será a causa destas diferenças? Vamos tentar explicar! Vamos analisar os
dados de cada módulo do {\it ristretto} 0.0.1. Na
tabela~\ref{tab:comparacao-metricas-ristretto-0.0.1} a métrica utilizada na
coluna falda de coesão é LCOM4.

\begin{table}
\caption{Métricas do ristretto 0.0.1}
\centering
\begin{tabular}{| l | c c | c c |}
\hline
Extrator          & \multicolumn{2}{|c|}{GCC}        & \multicolumn{2}{|c|}{Doxyparse} \\
\hline
Módulo            & Falta de Coesão & Acoplamento    & Falta de Coesão & Acoplamento   \\
\hline
main              & 1               & 4              & 1               & 3             \\
navigator         & 13              & 2              & 14              & 0             \\
picture\_viewer   & 2               & 2              & 2               & 1             \\
thumbnail\_viewer & 3               & 3              & 3               & 1             \\
\hline
\end{tabular}
\label{tab:comparacao-metricas-ristretto-0.0.1}
\end{table}

A diferença entre o acoplamento do módulo {\it navigator} é claramente
verificado pela figura~\ref{fig:ristretto-0.0.1-doxyparse-2} onde verifica-se
que este módulo não chama nenhum outro módulo.

O GCC diz que o módulo {\it main} tem acoplamento igual a 4, mas o grafo de
colaboração do ristretto 0.0.1 na figura~\ref{fig:ristretto-0.0.1-gcc} não
apresenta colaboração com 4 módulos, apenas com 3 e deacordo com o cálculo de
acoplamento utilizado aqui CBO, onde o acoplamento de um dado módulo é o número
de outros módulos com os quais ele colabora, esta informação está incorreta.
Mas o é importante saber porque o Doxyparse está correto e o GCC não, já que o
cálculo é feito da mesma maneira para os dois e o grafo de colaboracao também
estão iguais.

Avaliando o Egypt::Metrics, que é a classe responsavel pelo cálculo de métricas
no egypt verifiquei que o cálculo para acoplamento estava considerando métodos
externos, ou seja, métodos que são definidos fora do projeto, como chamadas a
métodos GTK\sigla{GTK}{GIMP Tool Kit} por exemplo. E o Doxyparse não foi
afetado por isto pois as chamadas a métodos externos são desconsideradas pelo
doxyparse.

O Egypt::Metrics foi alterado para considerar apenas métodos definidos no
projeto e o valor de acoplamento para o módulo main após a alteração ficou
certo, CBO(main) = 3. Esta correção corrigiram também as diferenças para
acoplamento dos outros módulos.

A diferença para o valor de falta de coesão não identificado.

\chapter{Conclusão} \label{ch:conclusao}

Os resultados obtidos foram satisfatórios e atingiram o objetivo inicial que
foi possibilitar extração de dados sem necessidade de compilar o software em
questão, algumas melhorias foram implementadas no egypt, um novo extrator e
correção de alguns bugs. Foi criada uma nova ferramenta baseada no Doxygen
chamada doxyparse para análise de código fonte de programas C/C++ em busca de
informação de colaboração entre os módulos do programa.

No anexo~\ref{ch:evolucao} é possível verificar a evolução da arquitetura do
ristretto em cada versão, é possível notar que em alguns momentos a arquitetura
do projeto sofre mudanças estruturais pelo surgimento de novos módulos, e em
outros momentos a evolução de uma versão a outra permanece inalterada apenas
com mudanças internas nos módulos onde o que se altera é apenas o número de
colaborações entre os módulos.

\section{Trabalhos futuros}

\begin{description}

\item[Testar egypt com outras linguagens além de C/C++]
O Doxygen suporta várias linguagens além de C/C++, testar o extrator Doxyparse
em projetos escritos nessas linguagens e verificar se o egypt e o doxyparse
funcionam bem e se necessário corrigir as falhas para que funcionem.

\item[Extrator baseado em Natural Docs]
Implementar novo extrator baseado em Natural
Docs\footnote{http://www.naturaldocs.org/}, uma ferramenta semelhante ao
Doxygen implementada em Perl com suporte a algumas linguagens, como Perl, Ruby
e ActionScript, não suportadas pelo Doxygen.

\item[Implementar no doxyparse detecção de chamada indireta]
O doxyparse identifica chamadas indiretas mas não as diferencia de chamadas
diretas.

\item[Armazenar símbolos externos ao projeto]
Os símbolos externos encontrados pelo doxyparse são descartados completamente,
é importante ter estas referencias para calcular outros tipos de métricas.

\end{description}
